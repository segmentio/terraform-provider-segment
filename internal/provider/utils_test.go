package provider

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestMergeSettings(t *testing.T) {
	t.Run("merges config-defined settings with remote values", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"key1":"configValue1","key2":"configValue2"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"key1":"remoteValue1","key2":"remoteValue2","key3":"remoteValue3"}`)

		result, err := mergeSettings(configSettings, remoteSettings, false)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Should contain config-defined keys with remote values
		assert.Equal(t, "remoteValue1", resultMap["key1"])
		assert.Equal(t, "remoteValue2", resultMap["key2"])

		// Should NOT contain backend-generated keys
		assert.NotContains(t, resultMap, "key3")
	})

	t.Run("excludes config keys missing in remote", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"key1":"configValue1","key2":"configValue2"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"key1":"remoteValue1"}`)

		result, err := mergeSettings(configSettings, remoteSettings, false)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Should use remote value when available
		assert.Equal(t, "remoteValue1", resultMap["key1"])

		// Should NOT include keys that are in config but not in remote
		assert.NotContains(t, resultMap, "key2")
		assert.Len(t, resultMap, 1)
	})

	t.Run("ignores backend-only settings", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"apiKey":"myKey"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"apiKey":"myKey","autoGeneratedField":"autoValue","internalFlag":true}`)

		result, err := mergeSettings(configSettings, remoteSettings, false)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Should only contain the config-defined key
		assert.Len(t, resultMap, 1)
		assert.Equal(t, "myKey", resultMap["apiKey"])
		assert.NotContains(t, resultMap, "autoGeneratedField")
		assert.NotContains(t, resultMap, "internalFlag")
	})

	t.Run("detects drift in config-defined settings", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"key1":"originalValue","key2":"originalValue2"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"key1":"driftedValue","key2":"originalValue2"}`)

		result, err := mergeSettings(configSettings, remoteSettings, false)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Should detect drift by using remote value
		assert.Equal(t, "driftedValue", resultMap["key1"])
		assert.Equal(t, "originalValue2", resultMap["key2"])
	})

	t.Run("handles empty config settings", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"key1":"remoteValue1"}`)

		result, err := mergeSettings(configSettings, remoteSettings, false)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Should return empty when config has no keys
		assert.Empty(t, resultMap)
	})

	t.Run("handles complex nested settings", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"nested":{"key1":"value1"},"simple":"value"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"nested":{"key1":"changedValue"},"simple":"value","extra":"ignored"}`)

		result, err := mergeSettings(configSettings, remoteSettings, false)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Should handle nested objects
		assert.Contains(t, resultMap, "nested")
		assert.Contains(t, resultMap, "simple")
		assert.NotContains(t, resultMap, "extra")
	})

	t.Run("returns error for invalid config JSON", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`invalid json`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"key":"value"}`)

		_, err := mergeSettings(configSettings, remoteSettings, false)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to unmarshal config settings")
	})

	t.Run("returns error for invalid remote JSON", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"key":"value"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`invalid json`)

		_, err := mergeSettings(configSettings, remoteSettings, false)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to unmarshal remote settings")
	})

	t.Run("preserves config password when isWarehouse is true", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"password":"secretPassword","username":"user123"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"username":"user123"}`)

		result, err := mergeSettings(configSettings, remoteSettings, true)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Password should be preserved from config even though it's not in remote
		assert.Equal(t, "secretPassword", resultMap["password"])
		assert.Equal(t, "user123", resultMap["username"])
	})

	t.Run("does not preserve password when isWarehouse is false", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"password":"secretPassword","username":"user123"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"username":"user123"}`)

		result, err := mergeSettings(configSettings, remoteSettings, false)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Password should NOT be included when not in remote and not a warehouse
		assert.NotContains(t, resultMap, "password")
		assert.Equal(t, "user123", resultMap["username"])
	})

	t.Run("preserves config value when remote secret is censored", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"apiKey":"mySecretKey","publicKey":"publicValue"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"apiKey":"••••••••","publicKey":"publicValue"}`)

		result, err := mergeSettings(configSettings, remoteSettings, false)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Censored secret should use config value
		assert.Equal(t, "mySecretKey", resultMap["apiKey"])
		// Non-censored value should use remote value
		assert.Equal(t, "publicValue", resultMap["publicKey"])
	})

	t.Run("handles multiple censored secrets", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"secret1":"value1","secret2":"value2","normal":"normalValue"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"secret1":"••••","secret2":"•••••••","normal":"normalValue"}`)

		result, err := mergeSettings(configSettings, remoteSettings, false)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Both censored secrets should use config values
		assert.Equal(t, "value1", resultMap["secret1"])
		assert.Equal(t, "value2", resultMap["secret2"])
		// Normal value should use remote value
		assert.Equal(t, "normalValue", resultMap["normal"])
	})

	t.Run("handles censored secrets in warehouse mode", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"password":"dbPassword","apiKey":"myApiKey","username":"user"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"apiKey":"••••••••","username":"user"}`)

		result, err := mergeSettings(configSettings, remoteSettings, true)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Password should be preserved (warehouse mode)
		assert.Equal(t, "dbPassword", resultMap["password"])
		// Censored API key should use config value
		assert.Equal(t, "myApiKey", resultMap["apiKey"])
		// Username should use remote value
		assert.Equal(t, "user", resultMap["username"])
	})

	t.Run("only treats strings with bullet character as censored", func(t *testing.T) {
		configSettings := jsontypes.NewNormalizedValue(`{"key1":"configValue","key2":"configValue2"}`)
		remoteSettings := jsontypes.NewNormalizedValue(`{"key1":"dotdotdot...","key2":"••••"}`)

		result, err := mergeSettings(configSettings, remoteSettings, false)

		require.NoError(t, err)

		var resultMap map[string]interface{}
		diags := result.Unmarshal(&resultMap)
		require.False(t, diags.HasError())

		// Regular dots should use remote value
		assert.Equal(t, "dotdotdot...", resultMap["key1"])
		// Bullet character should use config value
		assert.Equal(t, "configValue2", resultMap["key2"])
	})
}
